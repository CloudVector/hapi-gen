'use strict';

const RepositoryBase = require('../../lib/repository-base.js');
const ObjectID = require('mongodb').ObjectID;

const internals = {};

// Get a single entry back
internals.single = async (db, id) => {
    let query = { "_id": new ObjectID(id) };
    return await db.collection('gifs').findOne(query);
};

// Save stats into DB
internals.save = async (db, payload) => {
    return await db.collection('stats').insert(payload);
};

// Repository
class Repository extends RepositoryBase {
    // Constructor to receive options
    constructor (db) {
        super(db);
    }

    // Save
    async save (type, payload) {
        let result;
        let res = await internals.save(this.db, payload);
        result = {~lb} success: (res.insertedCount > 0) {~rb};
        return result;
    }

    // Returns the list (filtered)
    async list (search) {
        let query = {};
        let options = {};

        // Get the parameters but name's could be different, or could contain other data so pick out the search fields
        if (search.name) {
            query.name = search.name;
        }
        if (search.tag) {
            query.tags = {~lb} $in : [search.tag] {~rb};
        }
        if (search.page && search.limit) {
            options.limit = search.limit;
            options.skip = internals.skip(search.page, search.limit);
        }

        // Add sort, no limit for this task
        options.sort = search.sort;
        // Execute search
        return await this.db.collection('sample').find(query, options).toArray();
    }

    // Return a single item
    async get (id) {
        return await this.db.collection('sample').findOne({~lb} "_id": new ObjectID(id) {~rb});
    }

    // Return a single item
    async remove (id) {
        return await this.db.collection('sample').remove({~lb} "_id": new ObjectID(id) {~rb});
    }
}

module.exports = Repository; 